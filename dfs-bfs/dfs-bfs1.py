from itertools import  product
def solution(numbers , target):
    l = [(x, -x) for x in numbers] #각각의 원소가 +,-일때 l : [(1, -1), (1, -1), (1, -1), (1, -1), (1, -1)]
    s = list(map(sum, product(*l)))
    return s.count(target)

'''product는 l의 원소들끼리의 경우의 수
product(*l) :[(1, 1, 1, 1, 1), (1, 1, 1, 1, -1), (1, 1, 1, -1, 1), (1, 1, 1, -1, -1), (1, 1, -1, 1, 1),
    (1, 1, -1, 1, -1), (1, 1, -1, -1, 1), (1, 1, -1, -1, -1), (1, -1, 1, 1, 1), (1, -1, 1, 1, -1), (1, -1, 1, -1, 1), 
    (1, -1, 1, -1, -1), (1, -1, -1, 1, 1), (1, -1, -1, 1, -1), (1, -1, -1, -1, 1), (1, -1, -1, -1, -1), (-1, 1, 1, 1, 1), 
    (-1, 1, 1, 1, -1), (-1, 1, 1, -1, 1), (-1, 1, 1, -1, -1), (-1, 1, -1, 1, 1), (-1, 1, -1, 1, -1), (-1, 1, -1, -1, 1), 
    (-1, 1, -1, -1, -1), (-1, -1, 1, 1, 1), (-1, -1, 1, 1, -1), (-1, -1, 1, -1, 1), (-1, -1, 1, -1, -1), 
    (-1, -1, -1, 1, 1), (-1, -1, -1, 1, -1), (-1, -1, -1, -1, 1), (-1, -1, -1, -1, -1)]
s = [5, 3, 3, 1, 3, 1, 1, -1, 3, 1, 1, -1, 1, -1, -1, -3, 3, 1, 1, -1, 1, -1, -1, -3, 1, -1, -1, -3, -1, -3, -3, -5]

*****list(map(sum, _list))예시******
_list = [(1,1), (1,-1)]
print(list(map(sum, _list))) ## 중복제거되어 덧셈결과 나타남 [2,0]

***주의할 점: combinations, permutations, product 세 메소드 모두 generator이기 때문에 list()로 캐스팅하여 다른 곳에
저장 해두지 않으면 한 번의 루핑 이후 사라지게 된다.
        : iterator가 없으면 실행되지 않음 list에 하나의 원소만 있거나.. list=[1,2,3]등등
'''

print(solution([1,1,1,1,1], 3))

